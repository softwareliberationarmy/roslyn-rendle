using System.Collections;
using System.Net.NetworkInformation;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.MSBuild;
using NuGet.Protocol;
using rendle_ndc;

/// <summary>
/// Demo code from Mark Rendle's NDC 2022 talk on Roslyn
/// </summary>
public class RoslynDemo
{
    public async Task Start(string solutionPath)
    {
        MSBuildLocator.RegisterDefaults();

        var workspace = MSBuildWorkspace.Create();
        workspace.LoadMetadataForReferencedProjects = true;

        workspace.WorkspaceFailed += OnWorkspaceFailed;

        var solution = await workspace.OpenSolutionAsync(solutionPath);

        //TryGettingProject(solution);
        //await TryListingTypes(solution);
        //await TryWalkingFilesInstead(solution);
        //await TrySemanticModel(solution);
        //await TryFindingReferencedTypes(solution);
        //await TryRewritingAllCode(workspace);
    }

    private async Task TryRewritingAllCode(Workspace workspace)
    {
        var newSolution = workspace.CurrentSolution;

        int count = 0;

        foreach (var project in workspace.CurrentSolution.Projects)
        {
            var compilation = await project.GetCompilationAsync();
            if (compilation is null) continue;

            foreach (var document in project.Documents)
            {
                if (document.IsAutoGenerated()) continue;

                var root = await document.GetSyntaxRootAsync();
                if (root is null) continue;

                if (root.BeginsWithAutoGeneratedComment()) continue;

                var model = compilation.GetSemanticModel(root.SyntaxTree, true);

                var upshifter = new StringLiteralUpshifter(model);

                var newRoot = upshifter.Visit(root);

                if (!newRoot.IsEquivalentTo(root))
                {
                    ++count;
                    newSolution = newSolution.WithDocumentSyntaxRoot(document.Id, newRoot);
                }
            }
        }

        if (!ReferenceEquals(newSolution, workspace.CurrentSolution) && workspace.TryApplyChanges(newSolution))
        {
            Console.WriteLine($"{count} changes applied");
        }
        
    }

    private async Task TryFindingReferencedTypes(Solution solution)
    {
        var typeSet = new HashSet<string>();

        foreach (var project in solution.Projects)
        {
            var compilation = await project.GetCompilationAsync();
            if (compilation is null) continue;
            foreach (var document in project.Documents)
            {
                if (document.IsAutoGenerated()) continue;

                var tree = await document.GetSyntaxTreeAsync();
                if (tree is null) continue;
                
                var root = await tree.GetRootAsync();

                if (root.BeginsWithAutoGeneratedComment()) continue;

                var model = compilation.GetSemanticModel(tree, true);

                foreach (var namedTypeSymbol in GetTypes(root, model))
                {
                    typeSet.Add($"{namedTypeSymbol.ContainingNamespace}.{namedTypeSymbol.Name}");
                }
            }
        }

        foreach (var typeName in typeSet.OrderBy(x => x))
        {
            Console.WriteLine(typeName);
        }
    }

    private IEnumerable<INamedTypeSymbol> GetTypes(SyntaxNode root, SemanticModel model)
    {
        var namedTypes = root.DescendantNodes()
            .OfType<IdentifierNameSyntax>()
            .Select(s => model.GetSymbolInfo(s).Symbol)
            .OfType<INamedTypeSymbol>();

        var expressionTypes = root.DescendantNodes()
            .OfType<ExpressionSyntax>()
            .Select(s => model.GetTypeInfo(s).Type)
            .OfType<INamedTypeSymbol>();

        return namedTypes.Concat(expressionTypes).Distinct();
    }

    private async Task TrySemanticModel(Solution solution)
    {
        foreach (var project in solution.Projects)
        {
            var compilation = await project.GetCompilationAsync();
            if (compilation is null) continue;

            foreach (var document in project.Documents)
            {
                var tree = await document.GetSyntaxTreeAsync();
                if (tree is null) continue;

                var model = compilation.GetSemanticModel(tree);

                var root = await tree.GetRootAsync();

                foreach (var typeDeclarationSyntax in root.DescendantNodes().OfType<BaseTypeDeclarationSyntax>())
                {
                    if (ModelExtensions.GetDeclaredSymbol(model, typeDeclarationSyntax) is INamedTypeSymbol symbol)
                    {
                        Console.WriteLine($"{symbol.TypeKind}: {symbol.ContainingNamespace}.{symbol.Name}");

                        foreach (var methodSymbol in symbol.GetMembers().OfType<IMethodSymbol>())
                        {
                            if (!methodSymbol.IsImplicitlyDeclared)
                            {
                                Console.WriteLine($"\t{methodSymbol.Name} ({methodSymbol.DeclaredAccessibility})");
                            }
                        }
                    }
                }
            }
        }
    }

    private async Task TryWalkingFilesInstead(Solution solution)
    {
        Console.WriteLine("Type Walker Demo");
        var walker = new LukeTypeWalker();

        foreach (var document in solution.Projects.SelectMany(p => p.Documents))
        {
            var root = await document.GetSyntaxRootAsync();
            if (root is null) continue;
            walker.Visit(root);
        }
    }

    private async Task TryListingTypes(Solution solution)
    {
        foreach (var project in solution.Projects)
        {
            Console.WriteLine($"PROJECT: {project.Name}");

            foreach (var document in project.Documents)
            {
                Console.WriteLine($"\tFILE: {document.Name}");
                var root = await document.GetSyntaxRootAsync();
                if (root is null) continue;

                foreach (var typeDeclarationSyntax in root.DescendantNodes().OfType<BaseTypeDeclarationSyntax>())
                {
                    var namespaceDeclarationSyntax =
                        typeDeclarationSyntax.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();

                    var typeName = typeDeclarationSyntax.Identifier.Text;
                    var namespaceName = namespaceDeclarationSyntax?.Name.ToString();

                    Console.WriteLine($"\t\t{namespaceName}.{typeName}");
                }

            }
        }
    }

    private static void TryGettingProject(Solution solution)
    {
        var project = solution.Projects.FirstOrDefault();

        if (project != null)
        {
            Console.WriteLine($"Opening project {project.Name}");
        }
    }

    private void OnWorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
    {
        Console.WriteLine($"Workspace failed. {e.ToJson()}");
    }
}

public static class RoslynExtensions
{
    public static bool IsAutoGenerated(this Document myDocument)
    {
        var fileName = Path.GetFileNameWithoutExtension(myDocument.FilePath.AsSpan());

        return fileName.StartsWith("TemporaryGeneratedFile_", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".designer", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".generated", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".g", StringComparison.OrdinalIgnoreCase) ||
               fileName.EndsWith(".gi", StringComparison.OrdinalIgnoreCase);
    }

    public static bool BeginsWithAutoGeneratedComment(this SyntaxNode root)
    {
        if (root.HasLeadingTrivia)
        {
            var commentTrivia = root.GetLeadingTrivia().Where(t =>
                t.IsKind(SyntaxKind.MultiLineCommentTrivia) || t.IsKind(SyntaxKind.SingleLineCommentTrivia));

            foreach (var trivia in commentTrivia)
            {
                var text = trivia.ToString().AsSpan();
                if (text.Contains("autogenerated", StringComparison.OrdinalIgnoreCase) ||
                    text.Contains("auto-generated", StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }

            }
        }

        return false;
    }
}